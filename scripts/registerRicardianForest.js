require("dotenv").config({ path: "./environment_variables.env" });

const { ethers } = require("hardhat");
const fs = require("fs");
const IPFS = require("ipfs-http-client");
const axios = require("axios");
const { MerkleTree } = require("merkletreejs");
const keccak256 = require("keccak256");
const PDFDocument = require("pdfkit");

// --------------------
// FLAG IPFS (env)
// --------------------
const useIPFS = process.env.USE_IPFS === "true" || process.env.USE_IPFS === "1";

// --------------------
// IPFS CLIENT (daemon locale)
// --------------------
const ipfs = IPFS.create({ host: "localhost", port: "5002", protocol: "http" });

// --------------------
// UTILS
// --------------------
function toKeccak256(obj) {
  return ethers.keccak256(
    ethers.toUtf8Bytes(JSON.stringify(obj))
  );
}

function normalizeEpc(epcRaw, seed = "") {
  if (!epcRaw && !seed) return "";
  const s = String(epcRaw || "");
  if (s.toUpperCase().startsWith("E")) return s;
  const h = keccak256(s + "|" + seed).toString("hex").toUpperCase();
  return "E280" + h.slice(0, 20);
}

function hashUnified(obj) {
  return keccak256(
    `${obj.type}|${obj.epc}|${obj.firstReading}|${obj.treeType || ""}|${obj.coordinates || ""}|${obj.notes || ""}|${obj.parentTree || ""}|${obj.parentWoodLog || ""}|${obj.observations || ""}|${obj.forestUnitId || ""}|${obj.domainUUID || ""}|${obj.deleted ? 1 : 0}|${obj.lastModification || ""}`
  );
}

// --------------------
// UPLOAD + PIN IPFS
// --------------------
async function uploadToIPFS(json, filename) {
  fs.writeFileSync(filename, JSON.stringify(json, null, 2));
  const fileContent = fs.readFileSync(filename);

  // 1) ADD
  const { cid } = await ipfs.add({ path: filename, content: fileContent });
  const ipfsUri = `ipfs://${cid}/${filename}`;

  // 2) PIN
  await ipfs.pin.add(cid);

  return ipfsUri;
}

async function fetchFromIPFS(ipfsUri) {
  const parts = ipfsUri.replace("ipfs://", "").split("/");
  const cid = parts[0];

  const chunks = [];
  for await (const chunk of ipfs.cat(cid)) {
    chunks.push(chunk);
  }

  const fileContent = Buffer.concat(chunks).toString();
  return JSON.parse(fileContent);
}

async function getEthPriceInEuro() {
  try {
    const res = await axios.get(
      "https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=eur"
    );
    return res.data.ethereum.eur;
  } catch {
    console.warn("‚ö†Ô∏è Errore recupero ETH/EUR, uso default 3000");
    return 3000;
  }
}

function generateRicardianPdf(ricardian, outPath) {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ size: "A4", margin: 50, autoFirstPage: true });
    const stream = fs.createWriteStream(outPath);
    doc.pipe(stream);

    const M = doc.page.margins.left;
    const W = doc.page.width - doc.page.margins.left - doc.page.margins.right;

    const COLORS = {
      text: "#111111",
      muted: "#444444",
      faint: "#777777",
      line: "#D0D0D0",
      boxFill: "#F5F5F5",
      accent: "#0B3D2E"
    };

    const safe = (v) => (v === null || v === undefined ? "" : String(v));
    const boolStr = (b) => (b === true ? "true" : b === false ? "false" : "‚Äî");

    const fmtJurisdiction = (j) => {
      if (Array.isArray(j)) return j.join(", ");
      if (j && typeof j === "object") {
        const parts = [];
        if (j.courts) parts.push(`Courts: ${j.courts}`);
        if (Array.isArray(j.regulatoryFramework) && j.regulatoryFramework.length) {
          parts.push(`Regulatory: ${j.regulatoryFramework.join(", ")}`);
        }
        return parts.join(" | ");
      }
      return "";
    };

    function bottomY() {
      return doc.page.height - doc.page.margins.bottom;
    }

    function ensureSpace(needed) {
      if (doc.y + needed > bottomY()) {
        doc.addPage();
      }
    }

    // ---------------- FOOTER ----------------
    function addFooter() {
      const y = doc.page.height - doc.page.margins.bottom - 18;
      const prevY = doc.y;

      doc.save();
      doc.font("Helvetica").fontSize(8.5).fillColor(COLORS.faint);
      doc.text("Generated by RicardianForestTracking", M, y, { width: W, align: "left" });
      doc.text(safe(ricardian?.timestamps?.createdAt), M, y, { width: W, align: "right" });
      doc.restore();

      doc.y = prevY;
    }

    doc.on("pageAdded", addFooter);

    // ---------------- BOX SYSTEM ----------------
    function measureBoxHeight(fn, minH = 70) {
      const pad = 12;
      const innerW = W - pad * 2;

      const origText = doc.text.bind(doc);
      const origMoveDown = doc.moveDown.bind(doc);
      const origY = doc.y;

      doc._measureMode = true;
      doc._measureAcc = 0;

      doc.text = function (...args) {
        if (!doc._measureMode) return origText(...args);

        let text = typeof args[0] === "string" || typeof args[0] === "number"
          ? String(args[0] ?? "")
          : "";

        let options =
          typeof args[1] === "object" ? args[1] :
          typeof args[3] === "object" ? args[3] : {};

        const width = options.width ?? innerW;
        const lineGap = options.lineGap ?? 0;

        doc._measureAcc += doc.heightOfString(text, { width, lineGap }) || 0;
        doc._measureAcc += 2;
        return doc;
      };

      doc.moveDown = function (lines = 1) {
        if (!doc._measureMode) return origMoveDown(lines);
        doc._measureAcc += doc.currentLineHeight() * (lines || 1);
        return doc;
      };

      let innerH = 0;
      try {
        const ret = fn({ x: M + pad, w: innerW, measure: true });
        innerH = typeof ret === "number" ? ret : doc._measureAcc;
      } finally {
        doc._measureMode = false;
        doc.text = origText;
        doc.moveDown = origMoveDown;
        doc.y = origY;
      }

      return Math.max(minH, innerH + pad * 2);
    }

    function box(fn, minH = 70) {
      const pad = 12;
      const boxH = measureBoxHeight(fn, minH);

      ensureSpace(boxH + 20);

      const x = M;
      const y = doc.y;

      doc.save();
      doc.fillColor(COLORS.boxFill).strokeColor(COLORS.line);
      doc.rect(x, y, W, boxH).fillAndStroke();
      doc.restore();

      doc.y = y + pad;
      fn({ x: x + pad, w: W - pad * 2, measure: false });
      doc.y = y + boxH + 14;
    }

    function sectionBox(title, fn, minH = 70) {
      const titleH = 22;
      const boxH = measureBoxHeight(fn, minH);
      ensureSpace(titleH + boxH + 20);

      doc.font("Helvetica-Bold").fontSize(12).fillColor(COLORS.text);
      doc.text(title, M, doc.y, { width: W });
      doc.moveDown(0.4);

      box(fn, minH);
    }

    function kv(label, value, x, w) {
      doc.font("Helvetica-Bold").fontSize(10).fillColor(COLORS.muted);
      doc.text(label, x, doc.y, { width: w });
      doc.moveDown(0.15);

      doc.font("Helvetica").fontSize(10).fillColor(COLORS.text);
      doc.text(safe(value) || "‚Äî", x, doc.y, { width: w, lineGap: 2 });
      doc.moveDown(0.45);
    }

    function mono(label, value, x, w) {
      doc.font("Helvetica-Bold").fontSize(10).fillColor(COLORS.muted);
      doc.text(label, x, doc.y, { width: w });
      doc.moveDown(0.25);

      doc.font("Courier").fontSize(9).fillColor(COLORS.text);
      doc.text(safe(value) || "‚Äî", x, doc.y, { width: w, lineGap: 2 });
      doc.moveDown(0.6);
    }

    // ---------------- HEADER ----------------
    doc.save().fillColor(COLORS.accent).rect(M, M - 22, W, 16).fill().restore();
    doc.font("Helvetica-Bold").fontSize(18).fillColor(COLORS.text);
    doc.text("Ricardian Contract ‚Äì Forest Tracking", M, M + 5, { width: W, align: "center" });

    doc.moveDown(1);
    doc.font("Helvetica").fontSize(10).fillColor(COLORS.muted);
    doc.text(
      `Forest Unit: ${safe(ricardian?.scope?.forestUnitKey)}   ‚Ä¢   Type: ${safe(ricardian?.type)}   ‚Ä¢   Version: ${safe(ricardian?.version)}`,
      M,
      doc.y,
      { width: W }
    );

    addFooter();
    doc.moveDown(1);

    // ---------------- SECTIONS ----------------
    sectionBox("Legal & Jurisdiction", ({ x, w }) => {
      kv("Governing law", ricardian?.governingLaw, x, w);
      kv("Jurisdiction", fmtJurisdiction(ricardian?.jurisdiction), x, w);
      kv("Legal value", ricardian?.legal?.legalValue, x, w);
      kv("Statement", ricardian?.legal?.statement, x, w);
    }, 95);

    sectionBox("Actors & Scope", ({ x, w }) => {
      kv("Data owner", ricardian?.actors?.dataOwner, x, w);
      kv("Data producer", ricardian?.actors?.dataProducer, x, w);
      kv("Data consumer", ricardian?.actors?.dataConsumer, x, w);
      kv("Forest unit key", ricardian?.scope?.forestUnitKey, x, w);
      kv("Included data", (ricardian?.scope?.includedData || []).join(", "), x, w);
      kv("Purpose", ricardian?.purpose, x, w);
    }, 120);

    sectionBox("Human-readable Agreement", ({ x, w }) => {
      doc.font("Helvetica").fontSize(10.5).fillColor(COLORS.text);
      doc.text(ricardian?.humanReadableAgreement?.text || "‚Äî", x, doc.y, { width: w, lineGap: 3 });
      doc.moveDown(0.6);
      kv("Language", ricardian?.humanReadableAgreement?.language, x, w);
    }, 140);

    sectionBox("Rights & Duties", ({ x, w }) => {
      kv("Data owner", ricardian?.rightsAndDuties?.dataOwner, x, w);
      kv("Data producer", ricardian?.rightsAndDuties?.dataProducer, x, w);
      kv("Data consumer", ricardian?.rightsAndDuties?.dataConsumer, x, w);
    }, 95);

    sectionBox("Hash Binding", ({ x, w }) => {
      kv("Binds human-readable text", boolStr(ricardian?.hashBinding?.bindsHumanReadableText), x, w);
      kv("Binds dataset Merkle root", boolStr(ricardian?.hashBinding?.bindsDatasetMerkleRoot), x, w);
    }, 80);

    sectionBox("Technical Bindings", ({ x, w }) => {
      kv("Hash algorithm", ricardian?.technical?.hashAlgorithm, x, w);
      kv("Batch format", ricardian?.technical?.batchFormat, x, w);
      kv("Storage", ricardian?.technical?.storage, x, w);
      if (ricardian?.ipfsUri) kv("IPFS URI", ricardian.ipfsUri, x, w);
      mono("Merkle root", ricardian?.technical?.merkleRootUnified, x, w);
      mono("Ricardian hash", ricardian?.ricardianHash, x, w);
    }, 170);

    if (ricardian?.signature?.eip712) {
      sectionBox("EIP-712 Signature", ({ x, w }) => {
        const e = ricardian.signature.eip712;
        kv("Signer", e.signer, x, w);
        kv("ChainId", e.domain?.chainId, x, w);
        kv("Verifying contract", e.domain?.verifyingContract, x, w);
        mono("Signature", e.signature, x, w);
      }, 260);
    }

    doc.end();
    stream.on("finish", resolve);
    stream.on("error", reject);
  });
}

// --------------------
// MAIN
// --------------------
async function main() {
  const [signer] = await ethers.getSigners();
  console.log("Using account:", signer.address);

  // --------------------
  // 1) RECUPERA FOREST UNITS DAL BACKEND
  // --------------------
  const LOGIN_CREDENTIALS = { username: "operator", password: "1234567!" };
  let token;
  try {
    const res = await axios.post("https://digimedfor.topview.it/api/get-token/", LOGIN_CREDENTIALS, {
      httpsAgent: new (require("https").Agent)({ rejectUnauthorized: false })
    });
    token = res.data.access;
  } catch (e) {
    console.error("‚ùå Errore login:", e.message);
    process.exit(1);
  }

  let forestUnits;
  try {
    const res = await axios.get("https://digimedfor.topview.it/api/get-forest-units/", {
      headers: { Authorization: `Bearer ${token}` },
      httpsAgent: new (require("https").Agent)({ rejectUnauthorized: false })
    });
    forestUnits = res.data.forestUnits;
  } catch (e) {
    console.error("‚ùå Errore fetch forest units:", e.message);
    process.exit(1);
  }

  const forestKeys = Object.keys(forestUnits);
  if (forestKeys.length === 0) {
    console.error("‚ùå Nessuna forest unit disponibile.");
    process.exit(1);
  }

  const selectedForestKey = forestKeys[forestKeys.length - 1];
  const unit = forestUnits[selectedForestKey];
  console.log(`\n‚úÖ Forest Unit selezionata: ${unit.name || selectedForestKey}\n`);

  // --------------------
  // 2) COSTRUISCI BATCH UNIFICATO
  // --------------------
  const leaves = [];
  const batchWithProof = [];
  const seenEpcs = new Set();

  const formatDate = d => d ? new Date(d).toISOString() : "";

  function getObservations(obj) {
    if (!obj) return "";
    if (Array.isArray(obj.observations)) return obj.observations.join("; ");
    return obj.observations || "";
  }

  function addToBatch(obj) {
    const leafHash = hashUnified(obj);
    leaves.push(leafHash);
    batchWithProof.push({ ...obj });
    seenEpcs.add(obj.epc);
  }

  for (const treeId of Object.keys(unit.trees || {})) {
    const t = unit.trees[treeId];
    const treeEpc = t.EPC || t.epc || t.domainUUID || treeId;

    const treeObj = {
      type: "Tree",
      epc: treeEpc,
      firstReading: formatDate(t.firstReadingTime),
      treeType: t.treeType?.specie || t.treeTypeId || t.specie || "Unknown",
      coordinates: t.coordinates ? `${t.coordinates.latitude || t.coordinates.lat || ""},${t.coordinates.longitude || t.coordinates.lon || ""}`.replace(/(^,|,$)/g, "") : "",
      notes: Array.isArray(t.notes) ? t.notes.map(n => n.description || n).join("; ") : t.notes || "",
      observations: getObservations(t),
      forestUnitId: selectedForestKey,
      domainUUID: t.domainUUID || t.domainUuid,
      deleted: t.deleted || false,
      lastModification: t.lastModification || t.lastModfication || ""
    };
    addToBatch(treeObj);

    for (const logKey of Object.keys(t.woodLogs || {})) {
      let log = t.woodLogs[logKey];
      if (typeof log === "string") log = (unit.woodLogs && unit.woodLogs[log]) || {};
      const logEpc = normalizeEpc(log.EPC || log.epc || log.domainUUID, treeEpc);
      if (seenEpcs.has(logEpc)) continue;

      const logObj = {
        type: "WoodLog",
        epc: logEpc,
        firstReading: formatDate(log.firstReadingTime),
        treeType: t.treeType?.specie || t.treeTypeId || "Unknown",
        logSectionNumber: log.logSectionNumber || 1,
        parentTree: treeEpc,
        coordinates: log.coordinates ? `${log.coordinates.latitude || log.coordinates.lat || ""},${log.coordinates.longitude || log.coordinates.lon || ""}`.replace(/(^,|,$)/g, "") : "",
        notes: Array.isArray(log.notes) ? log.notes.map(n => n.description || n).join("; ") : log.notes || "",
        observations: getObservations(log),
        forestUnitId: selectedForestKey,
        domainUUID: log.domainUUID || log.domainUuid,
        deleted: log.deleted || false,
        lastModification: log.lastModification || log.lastModfication || ""
      };
      addToBatch(logObj);

      for (const stKey of Object.keys(log.sawnTimbers || {})) {
        let st = log.sawnTimbers[stKey];
        if (typeof st === "string") st = (unit.sawnTimbers && unit.sawnTimbers[st]) || { EPC: st };

        const stEpc = normalizeEpc(st.EPC || st.epc || st.domainUUID || stKey, logEpc);
        if (seenEpcs.has(stEpc)) continue;

        const stObj = {
          type: "SawnTimber",
          epc: stEpc,
          firstReading: formatDate(st.firstReadingTime),
          treeType: t.treeType?.specie || t.treeTypeId || "Unknown",
          parentTreeEpc: treeEpc,
          parentWoodLog: logEpc,
          coordinates: st?.coordinates ? `${st.coordinates.latitude || st.coordinates.lat || ""},${st.coordinates.longitude || st.coordinates.lon || ""}`.replace(/(^,|,$)/g, "") : "",
          notes: Array.isArray(st?.notes) ? st.notes.map(n => n.description || n).join("; ") : st?.notes || "",
          observations: getObservations(st),
          forestUnitId: selectedForestKey,
          domainUUID: st?.domainUUID || st?.domainUuid,
          deleted: st?.deleted || false,
          lastModification: st?.lastModification || st?.lastModfication || ""
        };
        addToBatch(stObj);
      }
    }
  }

  // --------------------
  // 3) MERKLE TREE UNIFICATO
  // --------------------
  const merkleTree = new MerkleTree(leaves, keccak256, { sortPairs: true });
  const root = merkleTree.getHexRoot();
  console.log("\nüîë Merkle Root:", root);

    // --------------------
  // 3.5) EIP-712 DOMAIN INFO
  // --------------------
  const network = await ethers.provider.getNetwork();
  const chainId = Number(network.chainId);

  const verifyingContract = process.env.FOREST_CONTRACT_ADDRESS;
  console.log("üÜî Chain ID:", chainId);
  console.log("üèõÔ∏è Verifying Contract:", verifyingContract);

    // --------------------
  // 4) RICARDIAN JSON (base, poi firma EIP-712)
  // --------------------
  const ricardianBase = {
    version: "1.0",
    type: "RicardianForestTracking",

    jurisdiction: {
      "courts": "Foro competente italiano",
      "regulatoryFramework": ["IT", "EU"]
    },

    governingLaw: "Diritto della Repubblica Italiana e normativa dell'Unione Europea applicabile",

    actors: {
      dataOwner: "TopView Srl",
      dataProducer: "Operatore drone",
      dataConsumer: "Cliente finale"
    },

    purpose: "Tracciabilit√† e prova di integrit√† dei dati forestali",

    scope: {
      forestUnitKey: selectedForestKey,
      includedData: ["trees", "wood_logs", "sawn_timbers"]
    },

    humanReadableAgreement: {
      language: "it",
      text: `
Il presente accordo disciplina la raccolta, la registrazione, la conservazione
e la verifica dell‚Äôintegrit√† dei dati forestali relativi all‚Äôunit√† forestale
"${selectedForestKey}".

Le parti riconoscono che il dataset √® memorizzato off-chain e che l‚Äôhash
crittografico registrato su blockchain costituisce prova di esistenza,
immutabilit√† e integrit√† dei dati alla data di registrazione.

Il presente documento √® strutturato come contratto ricardiano, essendo
interpretabile sia da esseri umani sia da sistemi automatici.
`.trim()
    },

    rightsAndDuties: {
      dataOwner: "Detiene la titolarit√† dei dati e autorizza la loro registrazione e verifica",
      dataProducer: "Garantisce la correttezza della raccolta e l'origine dei dati",
      dataConsumer: "Pu√≤ verificare l‚Äôintegrit√† dei dati ma non modificarli"
    },

    technical: {
      merkleRootUnified: root,
      batchFormat: "JSON",
      storage: useIPFS ? "IPFS" : "LOCAL_FILE",
      hashAlgorithm: "keccak256"
    },

    legal: {
      legalValue: "Valore probatorio ai sensi della normativa vigente",
      statement:
        "L'hash registrato on-chain costituisce prova di esistenza e integrit√† del dataset alla data di registrazione."
    },

    hashBinding: {
      bindsHumanReadableText: true,
      bindsDatasetMerkleRoot: true
    },

    canonicalization: {
      "format": "UTF-8",
      "ordering": "lexicographic",
      "whitespace": "normalized"
    },

    timestamps: {
      createdAt: new Date().toISOString()
    }
  };

  // Hash "base" (senza firma, stabile)
  const ricardianHash = toKeccak256(ricardianBase);
  console.log("Ricardian hash (base):", ricardianHash);

  // --------------------
  // 4.5) FIRMA EIP-712 (off-chain)
  // --------------------
  const domain = {
    name: "RicardianForestTracking",
    version: "1",
    chainId,
    verifyingContract
  };

  const types = {
    RicardianForest: [
      { name: "forestUnitKey", type: "string" },
      { name: "ricardianHash", type: "bytes32" },
      { name: "merkleRoot", type: "bytes32" },
      { name: "createdAt", type: "string" }
    ]
  };

  const message = {
    forestUnitKey: selectedForestKey,
    ricardianHash,
    merkleRoot: root,
    createdAt: ricardianBase.timestamps.createdAt
  };

  const eip712Signature = await signer.signTypedData(domain, types, message);

  // Verifica (debug utile)
  const recovered = ethers.verifyTypedData(domain, types, message, eip712Signature);
  if (recovered.toLowerCase() !== signer.address.toLowerCase()) {
    throw new Error("‚ùå Firma EIP-712 non valida: recovered diverso dal signer");
  }
  console.log("‚úÖ EIP-712 signature ok. Signer:", signer.address);

  // Ora il Ricardian completo (base + firma)
  const ricardianForest = {
    ...ricardianBase,
    ricardianHash, // mettiamo anche dentro al JSON per leggibilit√†
    signature: {
      eip712: {
        signer: signer.address,
        domain,
        types,
        message,
        signature: eip712Signature
      }
    }
  };


    // --------------------
  // 5) SALVA JSON (e opzionale IPFS) + GENERA PDF
  // --------------------
  let ipfsPath = null;

  // Salvo sempre localmente (comodo per PDF / debug)
  fs.writeFileSync("ricardian-forest.json", JSON.stringify(ricardianForest, null, 2));
  console.log("Saved Ricardian locally: ricardian-forest.json");

  if (useIPFS) {
    ipfsPath = await uploadToIPFS(ricardianForest, "ricardian-forest.json");
    console.log("Uploaded Ricardian to:", ipfsPath);

    // utile anche nel PDF / JSON
    ricardianForest.ipfsUri = ipfsPath;
    fs.writeFileSync("ricardian-forest.json", JSON.stringify(ricardianForest, null, 2));
  }

  // PDF
  const pdfPath = "ricardian-forest.pdf";
  await generateRicardianPdf(ricardianForest, pdfPath);
  console.log("üìÑ PDF generato:", pdfPath);


  // --------------------
// 6) REGISTRA ON-CHAIN (con stima gas)
// --------------------
const ForestTracking = await ethers.getContractAt(
  "ForestTracking",
  process.env.FOREST_CONTRACT_ADDRESS
);

// --- STIMA GAS ---
const gasEstimate = await ethers.provider.estimateGas({
  to: process.env.FOREST_CONTRACT_ADDRESS,
  data: ForestTracking.interface.encodeFunctionData(
    "registerRicardianForest",
    [
      selectedForestKey,
      ricardianHash,
      root,
      ipfsPath || "file://ricardian-forest.json"
    ]
  ),
  from: signer.address
});

const feeData = await ethers.provider.getFeeData();
const gasPrice = feeData.gasPrice || ethers.parseUnits("20", "gwei");
const gasCostWei = gasEstimate * gasPrice;
const gasCostEth = Number(ethers.formatEther(gasCostWei));
const ethPrice = await getEthPriceInEuro();

console.log(
  `‚õΩ Gas stimato: ${gasEstimate.toString()} | ` +
  `Costo: ${gasCostEth.toFixed(6)} ETH ‚âà ‚Ç¨${(gasCostEth * ethPrice).toFixed(2)}`
);

// --- INVIO TRANSAZIONE ---
console.log("‚è≥ Invio transazione per registrare il Ricardian Contract...");

const tx = await ForestTracking.registerRicardianForest(
  selectedForestKey,
  ricardianHash,
  root,
  ipfsPath || "file://ricardian-forest.json"
);

const receipt = await tx.wait();

console.log("‚úÖ Ricardian Forest registered on-chain");
console.log("üîó Tx hash:", receipt.transactionHash || tx.hash);
console.log("üì¶ Block number:", receipt.blockNumber);

  // --------------------
  // 7) VERIFICA HASH IPFS (solo se USE_IPFS=true)
  // --------------------
  if (useIPFS) {
    console.log("\nVerifying Ricardian JSON...");
    const fetchedJSON = await fetchFromIPFS(ipfsPath);
    const fetchedHash = toKeccak256(fetchedJSON);
    if (fetchedHash === ricardianHash) console.log("‚úÖ IPFS JSON hash matches on-chain Ricardian hash");
    else console.log("‚ùå Hash mismatch!");
  }

  // --------------------
  // 8) VERIFICA MERKLE PROOF
  // --------------------
  console.log("\nVerifying Merkle proofs for all leaves...");
  let validCount = 0;
  let invalidCount = 0;

  for (let i = 0; i < leaves.length; i++) {
    const leaf = leaves[i];
    const obj = batchWithProof[i];
    const proof = merkleTree.getProof(leaf).map(x => '0x' + x.data.toString('hex'));

    const isValid = merkleTree.verify(proof, leaf, merkleTree.getRoot());
    //console.log(`Leaf ${i + 1}: EPC ${obj.epc} | Proof valid: ${isValid}`);

    if (isValid) validCount++;
    else invalidCount++;
  }

  console.log("\n‚úÖ Proof valide:", validCount, "/", leaves.length);
  console.log("‚ùå Proof non valide:", invalidCount, "/", leaves.length);

  // --------------------
  // 9) SALVA BATCH JSON CON PROOF
  // --------------------
  const outputDir = "./file-json";
  if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir);
  fs.writeFileSync(`${outputDir}/forest-unified-batch.json`, JSON.stringify(batchWithProof, null, 2));
  console.log("üíæ Salvato batch JSON con proof: forest-unified-batch.json");
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});